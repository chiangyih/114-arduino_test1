# 藍牙資料格式快速參考

## 📋 基本資訊

| 項目 | 值 |
|------|-----|
| **通訊方式** | UART 序列埠 |
| **鮑率** | 9600 bps |
| **資料格式** | ASCII 文字 |
| **命令結束** | `\n` 或 `\r\n` |
| **回應格式** | `ACK` 或 `ERR` |

---

## 🎯 命令速查表

| 命令 | 格式 | 參數 | 功能 | 回應 | 備註 |
|------|------|------|------|------|------|
| **CONNECT** | `CONNECT\n` | 無 | 建立連線 | ACK | 精確匹配 |
| **DISCONNECT** | `DISCONNECT\n` | 無 | 中斷連線 | ACK | 精確匹配 |
| **PING** | `PING\n` | 無 | 心跳確認 | ACK | 精確匹配 |
| **LOAD** | `LOAD <VAL>\n` | 0-100 | 設定 WS2812 | ACK | 寬鬆匹配¹ |
| **WRITE** | `WRITE <DEC>\n` | 0-255 | 寫入 EEPROM | ACK/ERR | 寬鬆匹配¹ |

¹ **寬鬆匹配說明**：  
- 只要字串中包含命令關鍵字（LOAD 或 WRITE）即可識別
- 自動搜尋字串中的數字並提取
- 容忍亂碼和格式不規範的資料（例如 `LOAD  50` 或 `WRITE  123`）

---

## 💡 命令範例

### 標準格式發送
```python
import serial
ser = serial.Serial('COM5', 9600)

ser.write(b'CONNECT\n')      # 連線
ser.write(b'LOAD 50\n')      # CPU 50%
ser.write(b'WRITE 123\n')    # 寫入 123
ser.write(b'PING\n')         # 心跳
ser.write(b'DISCONNECT\n')   # 中斷
```

### 容錯格式（仍可被識別）
```
LOAD  50         # 多個空格
LOAD50           # 無空格
LOAD   100       # 多個空格
WRITE  255       # 多個空格
WRITE 0          # 標準
```

✅ 上述所有格式都能正確解析！

### 序列埠監視器測試
```
CONNECT
LOAD 30
LOAD 65
LOAD 90
WRITE 123
PING
DISCONNECT
```

---

## 🌈 WS2812 顏色對應

| CPU % | 顏色 | RGB | 範例命令 |
|-------|------|-----|---------|
| 0-50 | 🟢 綠色 | (0,255,0) | `LOAD 30` |
| 51-84 | 🟡 黃色 | (255,255,0) | `LOAD 65` |
| 85-100 | 🔴 紅色 | (255,0,0) | `LOAD 90` |

---

## 🔄 處理流程

```
收到字元 → 換行符？
           ├─ 是 → 處理命令 → 回傳 ACK/ERR → 清空緩衝
           └─ 否 → 累積字元 → 繼續接收
```

---

## ⚡ 關鍵程式碼

### 接收處理
```cpp
while (Serial.available() > 0) {
    char c = Serial.read();
    if (c == '\n' || c == '\r') {
        // 處理 receivedData
    } else {
        receivedData += c;
    }
}
```

### 命令識別（C++）
```cpp
// WRITE 命令：寬鬆匹配
if (strstr(receivedData, "WRITE") != NULL) {
    char* valuePtr = receivedData;
    while (*valuePtr != '\0' && !isdigit(*valuePtr)) {
        valuePtr++;
    }
    if (*valuePtr != '\0') {
        int value = atoi(valuePtr);
        // 驗證 0-255
    }
}
// LOAD 命令：寬鬆匹配
else if (strstr(receivedData, "LOAD") != NULL) {
    char* valuePtr = receivedData;
    while (*valuePtr != '\0' && !isdigit(*valuePtr)) {
        valuePtr++;
    }
    if (*valuePtr != '\0') {
        int cpuLoad = atoi(valuePtr);
        // 驗證 0-100
    }
}
```

---

## 🛡️ 故障恢復機制

### 資料損壞容錯
- **前導空格清理**：自動去除命令前的空格和 Tab
- **末尾空格清理**：自動去除命令後的空格和 Tab  
- **數字搜尋**：在整個字串中搜尋第一個數字
- **亂碼容忍**：`LOAD❌RLOAD 25❌LOAD 31` 會正確提取 `25`
- **緩衝區滿檢查**：超過 64 位元組自動清空並回傳 ERR

### 範例
```
收到：  LOAD❌RLOAD 25❌LOAD 31
處理：  尋找 "LOAD" → 找到
        搜尋數字 → 找到「25」
        驗證範圍 → 0-100 ✓
回應：  CPU Load: 25\nACK
```

## ⏱️ 時間設定

| 項目 | 時間 |
|------|------|
| 逾時判定 | 5 秒無資料 |
| 建議心跳 | 每 2-3 秒 |
| 命令間隔 | 建議 200ms |

---

## ⚠️ 注意事項

1. **命令必須大寫**（CONNECT 不能寫成 connect）
2. **必須加換行符號**（Python 用 `\n`）
3. **WRITE 命令參數範圍**：0-255（四位二進位或更大，最大 255）
4. **LOAD 命令參數範圍**：0-100（CPU 百分比）
5. **等待 ACK 回應**（發送後等待 200ms 讀取）

---

## 🐛 常見錯誤

| 錯誤 | 原因 | 解決方法 |
|------|------|---------|
| 沒有回應 | 忘記加 `\n` | 確保命令以換行結束 |
| 收到 ERR（WRITE） | 參數超出 0-255 | 檢查輸入的十進位數值 |
| 收到 ERR（LOAD） | 參數超出 0-100 | CPU % 必須在 0-100 內 |
| 命令無效 | 大小寫錯誤 | 使用大寫命令 |
| 逾時中斷 | 未發送心跳 | 每 2-3 秒發送 PING |

---

## 📊 ASCII 對照表（常用字元）

| 字元 | 16進位 | 10進位 | 說明 |
|------|-------|-------|------|
| `\n` | 0x0A | 10 | 換行（LF） |
| `\r` | 0x0D | 13 | 回車（CR） |
| 空格 | 0x20 | 32 | 空白字元 |
| `0` | 0x30 | 48 | 數字 0 |
| `A` | 0x41 | 65 | 大寫 A |
| `C` | 0x43 | 67 | 大寫 C |
| `L` | 0x4C | 76 | 大寫 L |

---

## 🎯 測試清單

- [ ] 發送 CONNECT，收到 ACK
- [ ] 發送 LOAD 30，WS2812 顯示綠色
- [ ] 發送 LOAD 65，WS2812 顯示黃色
- [ ] 發送 LOAD 90，WS2812 顯示紅色
- [ ] 發送 WRITE 123，收到 ACK
- [ ] 發送 PING，收到 ACK
- [ ] 發送 DISCONNECT，收到 ACK，LED 關閉
- [ ] 停止發送 6 秒，TFT 顯示 Disconnect

---

**版本**：v1.0  
**日期**：2025-01-19  
**更多資訊**：參考 `藍牙資料格式說明.md`
