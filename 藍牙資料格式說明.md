# 藍牙接收資料格式說明

## 概述

Arduino 透過 HC-05 藍牙模組接收來自 PC 端的資料，使用**文字格式**（ASCII）的命令列介面。

---

## 資料接收流程

### 1. 硬體層級
```
PC 端 → 藍牙 → HC-05 TX → Arduino RX (Pin 0) → Serial.read()
```

### 2. 序列埠設定
```cpp
Serial.begin(9600);  // 鮑率：9600 bps
```

| 參數 | 值 |
|------|-----|
| Baud Rate | 9600 bps |
| Data Bits | 8 |
| Parity | None |
| Stop Bits | 1 |
| Flow Control | None |

### 3. 資料接收機制

#### 逐字元讀取
```cpp
while (Serial.available() > 0) {
    char c = Serial.read();  // 讀取一個字元（1 byte）
    
    if (c == '\n' || c == '\r') {
        // 遇到換行符號，表示命令結束
        // 處理 receivedData 中累積的完整命令
    } else {
        receivedData += c;  // 累積字元
    }
}
```

#### 流程圖
```
接收字元 → 是換行符？
            ├─ 是 → 處理完整命令 → 清空 receivedData
            └─ 否 → 累積到 receivedData → 繼續接收
```

---

## 資料格式詳解

### 基本格式

所有命令都是**文字字串**，以**換行符號**結束：

```
<COMMAND> [參數]\n
```

或

```
<COMMAND> [參數]\r\n
```

### 字元編碼
- **編碼**：ASCII
- **大小寫**：命令必須大寫（如 `CONNECT`，不能是 `connect`）
- **分隔符**：空格（` `）用於分隔命令和參數
- **結束符**：換行符號（`\n` 或 `\r` 或 `\r\n`）

---

## 支援的命令格式

### 1. CONNECT 命令

**功能**：建立藍牙連線

**格式**：
```
CONNECT\n
```

**資料組成**：
```
C  O  N  N  E  C  T  \n
43 4F 4E 4E 45 43 54 0A  (16進位 ASCII)
```

**範例**：
```python
# Python 發送
ser.write(b'CONNECT\n')

# 或
ser.write('CONNECT\n'.encode())
```

**Arduino 處理**：
```cpp
if (receivedData == "CONNECT") {
    bleConnected = true;
    Serial.println("ACK");  // 回傳 ACK
}
```

**回應**：
```
ACK\n
```

---

### 2. DISCONNECT 命令

**功能**：中斷藍牙連線

**格式**：
```
DISCONNECT\n
```

**資料組成**：
```
D  I  S  C  O  N  N  E  C  T  \n
44 49 53 43 4F 4E 4E 45 43 54 0A  (16進位 ASCII)
```

**範例**：
```python
ser.write(b'DISCONNECT\n')
```

**Arduino 處理**：
```cpp
if (receivedData == "DISCONNECT") {
    bleConnected = false;
    Serial.println("ACK");
    // 清除 WS2812 顯示
}
```

**回應**：
```
ACK\n
```

---

### 3. PING 命令

**功能**：心跳確認，維持連線狀態

**格式**：
```
PING\n
```

**資料組成**：
```
P  I  N  G  \n
50 49 4E 47 0A  (16進位 ASCII)
```

**範例**：
```python
ser.write(b'PING\n')
```

**Arduino 處理**：
```cpp
if (receivedData == "PING") {
    bleConnected = true;
    Serial.println("ACK");
}
```

**回應**：
```
ACK\n
```

**用途**：
- 定期發送以避免逾時中斷（建議每 2-3 秒）
- 簡單的連線狀態確認

---

### 4. LOAD 命令

**功能**：更新 WS2812 LED 顏色（顯示 CPU Loading）

**格式**：
```
LOAD <VAL>\n
```

**參數**：
- `<VAL>`：CPU 使用率百分比（0-100 的整數）

**資料組成範例**（LOAD 65）：
```
L  O  A  D     6  5  \n
4C 4F 41 44 20 36 35 0A  (16進位 ASCII)
```

**範例**：
```python
# 發送 CPU 30%
ser.write(b'LOAD 30\n')

# 發送 CPU 65%
ser.write(b'LOAD 65\n')

# 發送 CPU 90%
ser.write(b'LOAD 90\n')
```

**Arduino 處理**：
```cpp
if (receivedData.startsWith("LOAD ")) {
    int cpuLoad = receivedData.substring(5).toInt();
    
    // 根據 cpuLoad 值設定顏色
    if (cpuLoad <= 50) {
        color = 綠色;  // 0-50%
    } else if (cpuLoad <= 84) {
        color = 黃色;  // 51-84%
    } else {
        color = 紅色;  // 85-100%
    }
    
    Serial.println("ACK");
}
```

**參數解析**：
```
"LOAD 65"
      ↓ substring(5) 從第 5 個字元開始取出
     "65"
      ↓ toInt() 轉換為整數
      65
```

**回應**：
```
ACK\n
```

**色彩對應**：
| CPU % | 顏色 | RGB |
|-------|------|-----|
| 0-50 | 🟢 綠色 | (0, 255, 0) |
| 51-84 | 🟡 黃色 | (255, 255, 0) |
| 85-100 | 🔴 紅色 | (255, 0, 0) |

---

### 5. WRITE 命令

**功能**：寫入資料到 EEPROM

**格式**：
```
WRITE <DEC>\n
```

**參數**：
- `<DEC>`：要寫入的十進位數值（0-255）

**資料組成範例**（WRITE 123）：
```
W  R  I  T  E     1  2  3  \n
57 52 49 54 45 20 31 32 33 0A  (16進位 ASCII)
```

**範例**：
```python
# 寫入數值 15
ser.write(b'WRITE 15\n')

# 寫入數值 123
ser.write(b'WRITE 123\n')

# 寫入數值 255
ser.write(b'WRITE 255\n')
```

**Arduino 處理**：
```cpp
if (receivedData.startsWith("WRITE ")) {
    int value = receivedData.substring(6).toInt();
    
    if (value >= 0 && value <= 255) {
        writeEEPROM(value);
        Serial.println("ACK");
    } else {
        Serial.println("ERR");  // 數值超出範圍
    }
}
```

**參數解析**：
```
"WRITE 123"
       ↓ substring(6) 從第 6 個字元開始取出
      "123"
       ↓ toInt() 轉換為整數
       123
```

**回應**：
- 成功：`ACK\n`
- 失敗：`ERR\n`（數值超出 0-255 範圍）

---

## 資料處理細節

### 1. 字串累積過程

```cpp
String receivedData = "";  // 全域變數

// 接收 "LOAD 50\n" 的過程
收到 'L' → receivedData = "L"
收到 'O' → receivedData = "LO"
收到 'A' → receivedData = "LOA"
收到 'D' → receivedData = "LOAD"
收到 ' ' → receivedData = "LOAD "
收到 '5' → receivedData = "LOAD 5"
收到 '0' → receivedData = "LOAD 50"
收到 '\n' → 觸發命令處理
```

### 2. 命令識別方式

```cpp
receivedData.trim();  // 去除前後空白

// 方法 1：完全比對
if (receivedData == "PING") {
    // 完全相等才執行
}

// 方法 2：前綴比對
if (receivedData.startsWith("LOAD ")) {
    // 只要前面是 "LOAD " 就執行
    // 後面的參數用 substring() 取出
}
```

### 3. 參數提取

#### LOAD 命令參數提取
```cpp
String cmd = "LOAD 65";
String param = cmd.substring(5);  // "65"
int value = param.toInt();        // 65
```

#### WRITE 命令參數提取
```cpp
String cmd = "WRITE 123";
String param = cmd.substring(6);  // "123"
int value = param.toInt();        // 123
```

### 4. trim() 功能說明

```cpp
receivedData.trim();
```

**作用**：去除字串前後的空白字元

**範例**：
```
" PING "  → trim() → "PING"
"LOAD 50\r\n" → trim() → "LOAD 50"  (去除 \r\n)
```

---

## 完整範例

### PC 端發送（Python）

```python
import serial
import time

# 開啟序列埠
ser = serial.Serial('COM5', 9600, timeout=1)
time.sleep(2)  # 等待 Arduino 重置

# 發送命令範例
ser.write(b'CONNECT\n')       # 建立連線
time.sleep(0.2)
print(ser.readline())         # 讀取 "ACK\n"

ser.write(b'LOAD 50\n')       # 設定 CPU 50%
time.sleep(0.2)
print(ser.readline())         # 讀取 "ACK\n"

ser.write(b'WRITE 123\n')     # 寫入 EEPROM
time.sleep(0.2)
print(ser.readline())         # 讀取 "ACK\n"

ser.write(b'PING\n')          # 心跳
time.sleep(0.2)
print(ser.readline())         # 讀取 "ACK\n"

ser.write(b'DISCONNECT\n')    # 中斷連線
time.sleep(0.2)
print(ser.readline())         # 讀取 "ACK\n"

ser.close()
```

### Arduino 接收處理流程

```cpp
void handleBluetoothData() {
    // 步驟 1：檢查是否有資料
    if (Serial.available() > 0) {
        lastBleDataTime = millis();
    }
    
    // 步驟 2：逐字元讀取
    while (Serial.available() > 0) {
        char c = Serial.read();
        
        // 步驟 3：判斷是否為命令結束
        if (c == '\n' || c == '\r') {
            if (receivedData.length() > 0) {
                // 步驟 4：處理命令
                receivedData.trim();
                
                // 步驟 5：命令識別與執行
                if (receivedData == "PING") {
                    Serial.println("ACK");
                }
                else if (receivedData.startsWith("LOAD ")) {
                    int val = receivedData.substring(5).toInt();
                    // 設定 WS2812 顏色
                    Serial.println("ACK");
                }
                // ... 其他命令
                
                // 步驟 6：清空緩衝區
                receivedData = "";
            }
        } else {
            // 步驟 7：累積字元
            receivedData += c;
        }
    }
}
```

---

## 特殊情況處理

### 1. 多個換行符號

**情況**：PC 端發送 `PING\r\n`（包含 CR+LF）

**處理**：
```cpp
if (c == '\n' || c == '\r') {
    // 任一換行符號都會觸發處理
    // trim() 會去除剩餘的 \r 或 \n
}
```

### 2. 空白字元

**情況**：PC 端發送 `" PING "` 或 `"LOAD  50"`

**處理**：
```cpp
receivedData.trim();  // 去除前後空白
// " PING " → "PING"
```

### 3. 錯誤命令

**情況**：收到未定義的命令（如 `HELLO`）

**處理**：
```cpp
// 目前實作：忽略未知命令，不回應
// 可以改為回傳 "ERR\n"
```

### 4. 參數錯誤

**情況**：`WRITE 300`（超出範圍）

**處理**：
```cpp
if (value >= 0 && value <= 255) {
    Serial.println("ACK");
} else {
    Serial.println("ERR");  // 回傳錯誤
}
```

---

## 資料格式總結表

| 命令 | 完整格式 | 參數類型 | 參數範圍 | 回應 |
|------|---------|---------|---------|------|
| CONNECT | `CONNECT\n` | 無 | - | ACK |
| DISCONNECT | `DISCONNECT\n` | 無 | - | ACK |
| PING | `PING\n` | 無 | - | ACK |
| LOAD | `LOAD <VAL>\n` | 整數 | 0-100 | ACK |
| WRITE | `WRITE <DEC>\n` | 整數 | 0-255 | ACK/ERR |

---

## 進階說明

### 1. 為什麼使用文字格式？

**優點**：
- ✅ 易於除錯（可直接在序列埠監視器測試）
- ✅ 程式碼簡單易懂
- ✅ 相容性好（各種語言都容易實作）
- ✅ 人類可讀

**缺點**：
- ❌ 資料量較大（相對於二進位）
- ❌ 解析需要字串處理

### 2. 與二進位格式比較

**文字格式**（目前使用）：
```
"LOAD 65\n" = 8 bytes
4C 4F 41 44 20 36 35 0A
```

**二進位格式**（如整合指南的封包格式）：
```
[0xFF][0x43][0x04][65][R][G][B][CHK][0xFE] = 9 bytes
```

**結論**：目前採用文字格式符合 FirmwareSpec.md 規範，簡單實用。

### 3. 緩衝區大小

```cpp
String receivedData = "";  // Arduino String 類別動態分配
```

**理論上限**：受 Arduino SRAM 限制（2KB）

**實際使用**：最長命令約 20 bytes（如 `WRITE 255\n`），安全

### 4. 接收速度

- **鮑率**：9600 bps = 約 960 bytes/秒
- **單一命令**：8-12 bytes = 約 0.01 秒
- **處理時間**：< 1 ms

**結論**：對於本應用（心跳 2 秒、CPU 更新 1 秒）完全足夠

---

## 除錯技巧

### 1. 序列埠監視器測試

**設定**：
- Baud Rate: 9600
- Line Ending: Newline（或 Both NL & CR）

**測試命令**：
```
CONNECT
LOAD 50
WRITE 123
PING
DISCONNECT
```

### 2. 查看接收資料

**新增除錯輸出**：
```cpp
// 在 handleBluetoothData() 中加入
if (c == '\n' || c == '\r') {
    if (receivedData.length() > 0) {
        Serial.print("DEBUG: Received [");
        Serial.print(receivedData);
        Serial.println("]");
        
        receivedData.trim();
        // ... 原有處理
    }
}
```

### 3. 檢查 16 進位資料

```cpp
Serial.print("Received byte: 0x");
Serial.println(c, HEX);
```

---

## 常見問題

### Q1: 為什麼要用 trim()？
**A**: 去除不同作業系統的換行符號差異（\n, \r, \r\n）

### Q2: 如果忘記加換行符號會怎樣？
**A**: Arduino 會一直等待，命令不會被處理，直到收到換行符號

### Q3: 可以連續快速發送命令嗎？
**A**: 可以，但建議每個命令間隔 200ms，等待 ACK 回應

### Q4: LOAD 可以接受小數嗎？
**A**: 不行，toInt() 只能解析整數

### Q5: 命令區分大小寫嗎？
**A**: 是的，必須使用大寫（CONNECT 不等於 connect）

---

**文件版本**：v1.0  
**最後更新**：2025-01-19  
**相關檔案**：src/main.cpp, FirmwareSpec.md
